/// @title Souls
/// @author Shivanshi Tyagi
/// @license Apache License, Version 2.0

/* Imports */
#include "@huffmate/data-structures/Hashmap.huff"
#include "@huffmate/utils/CommonErrors.huff"

/* Interface */
#define function set721(address, uint256, string) nonpayable returns ()
#define function set1155(address, uint256, string) nonpayable returns ()
#define function get(address, uint256) nonpayable returns (string memory)

/* Events */
#define event Soul(address indexed user, address indexed contract, uint256 indexed tokenId, string data)

/* Event Signatures */
#define constant SOUL_SIG = 0x88a3e3992df0b2e8056f93a6e513b007e6156dedafc21013ed8728bf09d29adc // keccak256("Soul(address,address,uint256,string)")

/* MAPPINGS */
#define constant SOUL_DATA_LOCATION = FREE_STORAGE_POINTER()

/// @notice Only Owner Modifier
#define macro ONLY_OWNER_MODIFIER() = takes (0) returns (0) {
    [OWNER_SLOT] sload                      // [owner]
    caller eq authed jumpi                  // []
    ONLY_OWNER(0x00)                        // []
    authed:                                 // []
}

/* Set ERC1155 Soul Data */
#define macro SET_ERC1155() = takes (3) returns () { // takes contract address, tokenId, and soul data to be stored
    // 1155 fork
    // we call balanceOf, if less than 0, we revert, otherwise we set value and then return 

    return
}

/* Set ERC721 Soul Data */
#define macro SET_ERC721() = takes (3) returns () { // takes contract address, tokenId, and soul data to be stored
    // 721 fork
    // we call ownerOf, if not ownerOf, we revert, otherwise we set value and then retur
     
    // Store the ownerOf function selector in memory to call
    // __FUNC_SIG(ownerOf)    // [sig_right_padded]
    // 0xE0 shl               // [sig_left_padded]
    // 0x20 mstore            // []

    // // Call the asset to get its owner
    // 0x20                   // [retSize]
    // 0x00                   // [retOffset, retSize]
    // 0x04                   // [argSize, retOffset, retSize]
    // 0x20                   // [argOffset, argSize, retOffset, retSize]

    // 0x04 calldataload      // [contractAddress]
    // 0x00 mstore            // store contractAddress at memory location 0x00
    // 0x00 mload             // [to, argOffset, argSize, retOffset, retSize]

    // gas                    // [gas, to, argOffset, argSize, retOffset, retSize]
    // staticcall             // [success]

    // // If the call failed, revert
    // cont jumpi             // []
    // 0x00 dup1 revert       // []
    // cont:

    // // Load the owner
    // 0x00 mload             // [owner]
    
    // // Compare owner in memory with caller
    // caller eq not revert jumpi // []

    // Call SET_SOUL_DATA
    // what is the stack at this point?  
    // 0x44 calldataload                              
    // 0x24 calldataload 
    // 0x04 calldataload          
    //SET_SOUL_DATA() // []
    return
}

/* Set Soul Data */
#define macro SET_SOUL_DATA() = takes(3) returns () {
    // input stack: [contractAddress, tokenId, data] 
    [SOUL_DATA_LOCATION] // [slot, contractAddress, tokenId, data]
    STORE_ELEMENT_FROM_KEYS_2D(0x00)
    stop
}

// Viewable Function Macros

/* Retrieve Soul Data */
/// @title GET
/// @notice Entry point for: get(address,uint256)
/// @dev Slices account and address from calldata and retrieves the soul data
/// @param {calldata} [address account, uint256 tokenId]
/// @return {return} [string memory soulData]
#define macro GET() = takes (2) returns (1) { // takes contract address and tokenId
    0x24 calldataload                               // [tokenId]
    0x04 calldataload                               // [contractAddress, tokenId]

    GET_SOUL_DATA()                                 // [soulData]
    0x00 mstore                                     // [] store into mem
    0x20 0x00 return                                // [] return 32 bytes
}

/* Retrieve Soul Data */
/// @title Get Soul Data
/// @notice Get the soul data of a token for a given contractAddress.
/// @dev Uses LOAD_ELEMENT_FROM_KEYS_2D under the hood to perform a nested mapping lookup
/// @param {stack} [contractAddress, tokenId]
/// @return {stack} [soulData]
#define macro GET_SOUL_DATA() = takes (2) returns (1) {
    // input stack: [contractAddress, tokenId]
    [SOUL_DATA_LOCATION]                            // [SOUL_DATA_LOCATION, contractAddress, tokenId]
    LOAD_ELEMENT_FROM_KEYS_2D(0x00)                 // [soulData]
}

/* Main Macro - The contract entrypoint */
#define macro MAIN() = takes(0) returns (0) {
    // Identify which function is being called using the 4 byte function signature
    0x00 calldataload 0xe0 shr
    dup1 __FUNC_SIG(set721) eq set721 jumpi
    dup1 __FUNC_SIG(set1155) eq set1155 jumpi
    dup1 __FUNC_SIG(get) eq get jumpi

    // Revert if no signatures match
    0x00 0x00 revert
    
    set721:
      SET_ERC721()
    set1155:
      SET_ERC1155()
    get:
      GET()
}
